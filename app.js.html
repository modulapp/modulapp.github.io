<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="App.html">App</a><ul class='members'><li data-type='member'><a href="App.html#.events">events</a></li><li data-type='member'><a href="App.html#.status">status</a></li><li data-type='member'><a href="App.html#config">config</a></li><li data-type='member'><a href="App.html#id">id</a></li><li data-type='member'><a href="App.html#options">options</a></li><li data-type='member'><a href="App.html#status">status</a></li></ul><ul class='methods'><li data-type='method'><a href="App.html#addConfig">addConfig</a></li><li data-type='method'><a href="App.html#addOptions">addOptions</a></li><li data-type='method'><a href="App.html#destroy">destroy</a></li><li data-type='method'><a href="App.html#resolve">resolve</a></li><li data-type='method'><a href="App.html#setup">setup</a></li><li data-type='method'><a href="App.html#start">start</a></li><li data-type='method'><a href="App.html#stop">stop</a></li></ul></li><li><a href="Module.html">Module</a><ul class='members'><li data-type='member'><a href="Module.html#.events">events</a></li><li data-type='member'><a href="Module.html#.status">status</a></li><li data-type='member'><a href="Module.html#dependencies">dependencies</a></li><li data-type='member'><a href="Module.html#id">id</a></li><li data-type='member'><a href="Module.html#options">options</a></li><li data-type='member'><a href="Module.html#status">status</a></li><li data-type='member'><a href="Module.html#version">version</a></li></ul><ul class='methods'><li data-type='method'><a href="Module.html#addDependencies">addDependencies</a></li><li data-type='method'><a href="Module.html#addOptions">addOptions</a></li><li data-type='method'><a href="Module.html#destroy">destroy</a></li><li data-type='method'><a href="Module.html#disable">disable</a></li><li data-type='method'><a href="Module.html#enable">enable</a></li><li data-type='method'><a href="Module.html#setup">setup</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="App.html#event:destroyed">destroyed</a></li><li><a href="App.html#event:destroying">destroying</a></li><li><a href="App.html#event:resolved">resolved</a></li><li><a href="App.html#event:resolving">resolving</a></li><li><a href="App.html#event:setting_up">setting_up</a></li><li><a href="App.html#event:setup">setup</a></li><li><a href="App.html#event:started">started</a></li><li><a href="App.html#event:starting">starting</a></li><li><a href="App.html#event:stopped">stopped</a></li><li><a href="App.html#event:stopping">stopping</a></li><li><a href="Module.html#event:destroyed">destroyed</a></li><li><a href="Module.html#event:destroying">destroying</a></li><li><a href="Module.html#event:disabled">disabled</a></li><li><a href="Module.html#event:disabling">disabling</a></li><li><a href="Module.html#event:enabled">enabled</a></li><li><a href="Module.html#event:enabling">enabling</a></li><li><a href="Module.html#event:setting_up">setting_up</a></li><li><a href="Module.html#event:setup">setup</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">app.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

const EventEmitter = require('events').EventEmitter;
const ErrorsFactory = require('errors-factory');
const _ = require('lodash');
const async = require('async');
const DepGraph = require('dependency-graph').DepGraph;

const ModuleWrapper = require('./moduleWrapper');

/**
 * Provide errors defined in ./resources/errors.json.
 * @const {Object}
 * @enum {Error}
 * @author nauwep &lt;nauwep.dev@gmail.com>
 * @since //TODO since
 * @access private
 */
const _errors = new ErrorsFactory(require('./resources/errors.json'));

/**
 * Provide the App events as defined in ./resources/events.json.
 * @const {Object}
 * @enum {String}
 * @author nauwep &lt;nauwep.dev@gmail.com>
 * @since //TODO since
 * @access private
 */
const _events = require('./resources/events.json').app;

/**
 * Provide the App status as defined in ./resources/status.json.
 * @const {Object}
 * @enum {String}
 * @author nauwep &lt;nauwep.dev@gmail.com>
 * @since //TODO since
 * @access private
 */
const _status = require('./resources/status.json').app;

/**
 * Handle all private properties of all App instances.
 * @type {WeakMap}
 * @readonly
 * @author nauwep &lt;nauwep.dev@gmail.com>
 * @since //TODO since
 * @access private
 */
const privateProps = new WeakMap();

/**
 * Change the status of an App instance.
 *
 * @param  {App} appInstance The App instance.
 * @param  {String} newStatus   The new status to set.
 *
 * @throws {Error} ERR_APP_015 if the status is not a [supported status]{@link App.status}.
 *
 * @author nauwep &lt;nauwep.dev@gmail.com>
 * @since //TODO since
 * @access private
 */
function changeStatus(appInstance, newStatus) {

    if (!_.includes(_status, newStatus)) {
        throw _errors.ERR_APP_015;
    }

    let props = privateProps.get(appInstance);
    props.status = newStatus;
    privateProps.set(appInstance, props);
}

/**
 * Check a configuration module list. Remove nulls, duplicates, flatten the Array and check if all module are Module instance.
 *
 * @param  {?(Module|Array.&lt;Module>)} config The list of module to check.
 *
 * @return {!Array.&lt;Module>}  An Array of the cleaned configuration.
 *
 * @throws {Error} ERR_APP_013 if a module is not a Module instance.
 *
 * @author nauwep &lt;nauwep.dev@gmail.com>
 * @since //TODO since
 * @access private
 */
function checkConfig(config) {
    if (_.isNull(config)) {
        return [];
    } else if (config.constructor.name === 'Module') {
        return [config];
    } else if (_.isArray(config)) {

        config = _.flattenDeep(config);

        _.remove(config, (value) => {
            return _.isNull(value);
        });
        _.forEach(config, (value) => {
            if (value.constructor.name !== 'Module') {
                throw _errors.ERR_APP_013;
            }
        });
        config = _.flattenDeep(config);
        config = _.uniq(config);

        return config;
    } else {
        throw _errors.ERR_APP_013;
    }
}

/**
 * Class representing an App.
 *
 * @emits App#resolving
 * @emits App#resolved
 * @emits App#setting_up
 * @emits App#setup
 * @emits App#starting
 * @emits App#started
 * @emits App#stopping
 * @emits App#stopped
 * @emits App#destroying
 * @emits App#destroyed
 *
 * @class
 * @author nauwep &lt;nauwep.dev@gmail.com>
 * @since //TODO since
 * @access public
 * @extends EventEmitter
 */
class App extends EventEmitter {

    /**
     * Provide a new instance of App.
     *
     * The config and options are optionnal.
     *
     * @param {?(Module|Array.&lt;Module>|Object)} [config=[]] The list of modules.
     * @param {?Object} [options={}] Options for the modules.
     *
     * @throws {Error} ERR_APP_013 if a module is not a Module instance.
     * @throws {Error} ERR_APP_011 if options is not an Object.
     */
    constructor(config = [], options = {}) {

        if (_.isNull(config)) {
            config = [];
        }
        if (_.isNull(options)) {
            options = {};
        }

        if (_.isPlainObject(config)) {
            options = config;
            config = [];
        }

        config = checkConfig(config);

        if (!_.isPlainObject(options)) {
            throw _errors.ERR_APP_011;
        }

        super();

        // store all properties in the private WeakMap
        privateProps.set(this, {
            id: _.uniqueId(),
            config: config,
            graph: new DepGraph(),
            options: options,
            status: _status.CREATED
        });
    }

    /**
     * All supported events of App class.
     *
     * @type {!Object}
     * @enum {String}
     *
     * @readonly
     * @static
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    static get events() {
        return _events;
    }

    /**
     * All supported status of App class.
     *
     * @type {!Object}
     * @enum {String}
     *
     * @readonly
     * @static
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    static get status() {
        return _status;
    }

    /**
     * The id of the app, randomly generated.
     *
     * @readonly
     * @type {!String}
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    get id() {
        return privateProps.get(this).id;
    }

    get config() {
        return privateProps.get(this).config;
    }

    /**
     * The configuration of the app.
     * Read-write property.
     * Getting config never return null, at least an empty Array [].
     * Setting null or undefined replaces the current config by an empty Array [].
     * Setting a module will build an Array with that single module.
     *
     * @param  {?(Module|Array.&lt;Module>)}  [newConfig=[]] The new dependencies.
     *
     * @type {!Array.&lt;Module>}
     *
     * @throws {Error} ERR_APP_013 if a module is not a Module instance.
     * @throws {Error} ERR_APP_014 if the module is not in [created status]{@link App#status}.
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    set config(newConfig = []) {
        // TODO if status in resolved, update the config and resolve again?
        if (this.status !== _status.CREATED) {
            throw _errors.ERR_APP_014;
        }
        privateProps.get(this).config = checkConfig(newConfig);
    }

    /**
     * The module dependency graph of the app.
     * Using [dependency-graph package]{@link https://www.npmjs.com/package/dependency-graph} to help resolve the dependency tree of the modules.
     * Getting graph never return null, at least an empty graph once the app has not been resolved yet.
     *
     * @type {!DepGraph}
     *
     * @readonly
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access private
     */
    get graph() {
        return privateProps.get(this).graph;
    }

    get options() {
        return privateProps.get(this).options;
    }

    /**
     * The options of the app's modules.
     * Read-write property.
     * Getting options never return null, at least an empty Object {}.
     * Setting null or undefined replaces the current options by an empty Object {}.
     *
     * @param  {?Object} [newOptions={}] The new options.
     *
     * @type {!Object}
     *
     * @throws {Error} ERR_APP_009 if the app is not in created status.
     * @throws {Error} ERR_APP_008 if not an Object
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    set options(newOptions = {}) {
        // TODO if status in resolved, update the wrapper in the graph?
        if (this.status !== _status.CREATED) {
            throw _errors.ERR_APP_009;
        }
        let props = privateProps.get(this);
        if (_.isNull(newOptions)) {
            props.options = {};
        } else if (_.isPlainObject(newOptions)) {
            props.options = newOptions;
        } else {
            throw _errors.ERR_APP_008;
        }
        privateProps.set(this, props);
    }

    /**
     * The status of the module. Is part of the [supported status]{@link App.status}.
     *
     * @type {!String}
     *
     * @readonly
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    get status() {
        return privateProps.get(this).status;
    }

    /**
     * Add options to the app's modules.
     *
     * @param {?Object} [options={}] The options to add.
     *
     * @throws {Error} ERR_APP_008 if the options parameter is not an Object.
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    addOptions(options = {}) {
        if (_.isPlainObject(options) || _.isNull(options)) {
            this.options = _.merge(this.options, options);
        } else {
            throw _errors.ERR_APP_008;
        }
    }

    /**
     * Add modules to the app's configuration.
     *
     * @param {...?(Module|Array.&lt;Module>)} [config] The modules to add.
     *
     * @throws {Error} ERR_APP_013 if a module is not a Module instance.
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    addConfig(...config) {
        config = checkConfig(config);
        config = _.concat(this.config, config);
        config = _.flattenDeep(config);
        config = _.uniq(config);
        this.config = config;
    }

    /**
     * Change the status of the app.
     *
     * @param {String} newStatus The new status to set.
     *
     * @throws {Error} ERR_APP_015 if the status is not a [supported status]{@link App.status}.
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access private
     */
    _changeStatus(newStatus) {
        changeStatus(this, newStatus);
    }

    /**
     * The callback to pass in the lifecycles methods of app.
     *
     * @callback App~LifecycleCB
     * @param {Error} err Any error raised while executing the method, null if none.
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     */

    /**
     * Resolve the dependencies of the modules.
     *
     * @param {?App~LifecycleCB} [callback] The callback executed after resolving.
     *
     * @throws {Error} ERR_APP_001
     * @throws {Error} ERR_APP_006
     * @throws {Error} ERR_APP_007
     * @throws {Error} ERR_APP_015 if the status is not a [supported status]{@link App.status}.
     * @throws {Error} ERR_MOD_004
     * @throws {Error} ERR_MOD_006
     * @throws {Error} ERR_MOD_007
     * @throws {Error} ERR_MOD_008
     * @throws {Error} ERR_MOD_009
     * @throws {Error} ERR_MOD_010
     * @throws {Error} ERR_MOD_011
     * @throws {Error} ERR_MOD_012
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    resolve(callback) {
        if (_.isNull(callback)) {
            callback = _.noop;
        }
        if (this.status === _status.STARTED) {
            if (_.isFunction(callback)) {
                return callback(_errors.ERR_APP_001);
            } else {
                throw _errors.ERR_APP_001;
            }
        }

        /**
         * Resolving event. When the app is about to be resolved.
         * @event App#resolving
         * @since //TODO since
         */
        this.emit(_events.RESOLVING);

        const nbModuleDefInConfig = this.config.length;

        _.forEach(this.config, (moduleDef) => {

            let moduleWrapper = new ModuleWrapper(moduleDef, this);
            let id = moduleWrapper.id;
            let dependencies = moduleWrapper.dependencies;

            if (_.has(this.options, id)) {
                moduleWrapper.addOptions(this.options[id]);
            }

            if (this.graph.hasNode(id)) {
                this.graph.setNodeData(id, moduleWrapper);
            } else {
                this.graph.addNode(id, moduleWrapper);
            }

            _.forEach(dependencies, (depId) => {
                if (!this.graph.hasNode(depId)) {
                    this.graph.addNode(depId);
                }
                this.graph.addDependency(id, depId);
            });

        });

        // Dependency cycle check
        let nodeIds = [];
        try {
            nodeIds = this.graph.overallOrder();
        } catch (err) {
            if (_.isFunction(callback)) {
                return callback(_errors.ERR_APP_006);
            } else {
                throw _errors.ERR_APP_006;
            }
        }

        // Missing module check
        if (nodeIds.length !== nbModuleDefInConfig) {
            let nodeIds = this.graph.overallOrder();
            let missingModule = [];
            _.forEach(nodeIds, (nodeId) => {
                let data = this.graph.getNodeData(nodeId);
                if (data.constructor.name !== 'ModuleWrapper') {
                    missingModule.push(nodeId);
                }
            });
            let missingModuleError = _errors.ERR_APP_007;
            missingModuleError.data = missingModule;
            if (_.isFunction(callback)) {
                return callback(missingModuleError);
            } else {
                throw missingModuleError;
            }
        }

        // Set the imports in each wrapper
        _.forEach(nodeIds, (nodeId) => {
            let wrapper = this.graph.getNodeData(nodeId);
            let depNodeIds = this.graph.dependenciesOf(nodeId);
            let imports = {};
            _.forEach(depNodeIds, (depNodeId) => {
                let depWrapper = this.graph.getNodeData(depNodeId);
                if (depWrapper.constructor.name === 'ModuleWrapper') {
                    imports[depNodeId] = depWrapper;
                }
            });
            wrapper.addImports(imports); // TODO is it raising errors?
            this.graph.setNodeData(nodeId, wrapper); // TODO required ?
        });

        /**
         * Resolved event. When the app has been resolved.
         * @event App#resolved
         * @since //TODO since
         */
        this.emit(_events.RESOLVED);
        changeStatus(this, _status.RESOLVED);
        if (_.isFunction(callback)) {
            return callback(null);
        }
    }

    /**
     * Setup every modules following the dependency graph.
     *
     * @param {?App~LifecycleCB} [callback] The callback executed after setting up.
     *
     * @see Module#setup
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    setup(callback = _.noop) {
        if (_.isNull(callback)) {
            callback = _.noop;
        }
        if (this.status === _status.STARTED) {
            return callback(_errors.ERR_APP_002);
        }

        if (this.status === _status.CREATED) {
            try {
                this.resolve();
            } catch (err) {
                return callback(err);
            }
        }

        /**
         * Setting up event. When the app is about to be setup.
         * @event App#setting_up
         * @since //TODO since
         */
        this.emit(_events.SETTING_UP);

        let nodeIds = this.graph.overallOrder();
        async.eachSeries(nodeIds, (nodeId, asyncCallback) => {
            let wrapper = this.graph.getNodeData(nodeId);
            if (wrapper.constructor.name === 'ModuleWrapper') {
                wrapper.setupModule(asyncCallback);
            } else {
                asyncCallback(null);
            }

        }, (err) => {
            if (err) {
                callback(err);
            } else {
                /**
                 * Setup event. When the app has been setup.
                 * @event App#setup
                 * @since //TODO since
                 */
                this.emit(_events.SETUP);
                changeStatus(this, _status.SETUP);
                callback(null);
            }
        });

    }

    /**
     * Enable every modules following the dependency graph.
     *
     * @param {?App~LifecycleCB} [callback] The callback executed after starting.
     *
     * @see Module#enable
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    start(callback = _.noop) {
        if (_.isNull(callback)) {
            callback = _.noop;
        }
        if (this.status === _status.STARTED) {
            return callback(_errors.ERR_APP_003);
        }

        if (this.status === _status.CREATED || this.status === _status.RESOLVED) {
            return this.setup((err) => {
                if (err) {
                    callback(err);
                } else {
                    this.start(callback);
                }
            });
        }

        /**
         * Starting event. When the app is about to be started.
         * @event App#starting
         * @since //TODO since
         */
        this.emit(_events.STARTING);

        let nodeIds = this.graph.overallOrder();
        async.eachSeries(nodeIds, (nodeId, asyncCallback) => {
            let wrapper = this.graph.getNodeData(nodeId);
            if (wrapper.constructor.name === 'ModuleWrapper') {
                wrapper.enableModule(asyncCallback);
            } else {
                asyncCallback(null);
            }

        }, (err) => {
            if (err) {
                callback(err);
            } else {
                /**
                 * Started event. When the app has been started.
                 * @event App#started
                 * @since //TODO since
                 */
                this.emit(_events.STARTED);
                changeStatus(this, _status.STARTED);
                callback(null);
            }
        });

    }

    /**
     * Disable every modules following the dependency graph.
     *
     * @param {?App~LifecycleCB} [callback] The callback executed after stopping.
     *
     * @see Module#disable
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    stop(callback = _.noop) {
        if (_.isNull(callback)) {
            callback = _.noop;
        }
        if (this.status !== _status.STARTED) {
            return callback(_errors.ERR_APP_004);
        }

        /**
         * Stopping event. When the app is about to be stopped.
         * @event App#stopping
         * @since //TODO since
         */
        this.emit(_events.STOPPING);

        let nodeIds = _.reverse(this.graph.overallOrder());
        async.eachSeries(nodeIds, (nodeId, asyncCallback) => {

            let wrapper = this.graph.getNodeData(nodeId);
            if (wrapper.constructor.name === 'ModuleWrapper') {
                wrapper.disableModule(asyncCallback);
            } else {
                asyncCallback(null);
            }

        }, (err) => {
            if (err) {
                callback(err);
            } else {
                /**
                 * Stopped event. When the app has been stopped.
                 * @event App#stopped
                 * @since //TODO since
                 */
                this.emit(_events.STOPPED);
                changeStatus(this, _status.STOPPED);
                callback(null);
            }
        });

    }

    /**
     * Destroy every modules following the dependency graph.
     *
     * @param {?App~LifecycleCB} [callback] The callback executed after destroying.
     *
     * @see Module#destroy
     *
     * @author nauwep &lt;nauwep.dev@gmail.com>
     * @since //TODO since
     * @access public
     */
    destroy(callback = _.noop) {
        if (_.isNull(callback)) {
            callback = _.noop;
        }
        if (this.status !== _status.STOPPED) {
            return callback(_errors.ERR_APP_005);
        }

        /**
         * Destroying event. When the app is about to be destroyed.
         * @event App#destroying
         * @since //TODO since
         */
        this.emit(_events.DESTROYING);

        let nodeIds = _.reverse(this.graph.overallOrder());
        async.eachSeries(nodeIds, (nodeId, asyncCallback) => {
            let wrapper = this.graph.getNodeData(nodeId);
            if (wrapper.constructor.name === 'ModuleWrapper') {
                wrapper.destroyModule(asyncCallback);
            } else {
                asyncCallback(null);
            }

        }, (err) => {
            if (err) {
                callback(err);
            } else {
                /**
                 * Destroyed event. When the app has been destroyed.
                 * @event App#destroyed
                 * @since //TODO since
                 */
                this.emit(_events.DESTROYED);
                callback(null);
            }
        });
    }
}

module.exports = App;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Mon Oct 31 2016 15:54:39 GMT+0100 (Paris, Madrid) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
